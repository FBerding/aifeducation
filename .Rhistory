abstract_eng = "Abstract",
abstract_native = "Zusammenfassung",
keywords_eng = c("Test", "Neural Net"),
keywords_native = c("Test", "Neuronales Netz")
)
desc <- classifier$get_model_description()
expect_equal(
object = desc$eng,
expected = "Description"
)
expect_equal(
object = desc$native,
expected = "Beschreibung"
)
expect_equal(
object = desc$abstract_eng,
expected = "Abstract"
)
expect_equal(
object = desc$abstract_native,
expected = "Zusammenfassung"
)
expect_equal(
object = desc$keywords_eng,
expected = c("Test", "Neural Net")
)
expect_equal(
object = desc$keywords_native,
expected = c("Test", "Neuronales Netz")
)
classifier$set_model_license("test_license")
expect_equal(
object = classifier$get_model_license(),
expected = c("test_license")
)
classifier$set_documentation_license("test_license")
expect_equal(
object = classifier$get_documentation_license(),
expected = c("test_license")
)
classifier$set_publication_info(
authors = personList(
person(given = "Max", family = "Mustermann")
),
citation = "Test Classifier",
url = "https://Test.html"
)
pub_info <- classifier$get_publication_info()
expect_equal(
object = pub_info$developed_by$authors,
expected = personList(
person(given = "Max", family = "Mustermann")
)
)
expect_equal(
object = pub_info$developed_by$citation,
expected = "Test Classifier"
)
expect_equal(
object = pub_info$developed_by$url,
expected = "https://Test.html"
)
})
}
# Test training of the classifier-------------------------------------------
if (!skip_training_test) {
# Create combinations for the training configuration
log_dir <- paste0(root_path_results, "/", generate_id(5))
create_dir(log_dir, trace = FALSE)
train_args_combinations <- generate_args_for_tests(
object_name = object_class_name,
method = "train",
max_samples = max_samples_training,
var_objects = list(),
necessary_objects = list(
data_embeddings = test_embeddings,
data_targets = target_data[[n_classes]]
),
var_override = list(
name = NULL,
label = "Classifier for Estimating a Postive or Negative Rating of Movie Reviews",
sustain_interval = 30,
act_fct = "elu",
rec_dropout = 0.1,
dense_dropout = 0.1,
encoder_dropout = 0.1,
trace = FALSE,
epochs = 20,
batch_size = 20,
ml_trace = 0,
n_cores = 2,
data_folds = 2,
pl_max_steps = 2,
pl_max = 1,
pl_anchor = 1,
pl_min = 0,
sc_min_k = 1,
sc_max_k = 2,
sustain_track = TRUE,
sustain_iso_code = "DEU",
data_val_size = 0.25,
lr_rate = 1e-3,
dense_size = 5,
rec_size = 5,
self_attention_heads = 2,
intermediate_size = 6,
lr_warm_up_ratio = 0.01,
log_dir = log_dir
)
)
for (j in seq(train_args_combinations$n_combos)) {
# Create test object with a given combination of args
classifier <- NULL
gc()
i <- sample(x = seq(test_combinations$n_combos), size = 1)
classifier <- create_object(object_class_name)
do.call(
what = classifier$configure,
args = test_combinations$args[[i]]
)
test_that(paste(
"training", object_class_name,
get_current_args_for_print(test_combinations$args[[i]]),
get_current_args_for_print(train_args_combinations$args[[j]])
), {
expect_no_error(
do.call(
what = classifier$train,
args = train_args_combinations$args[[j]]
)
)
expect_true(classifier$get_sustainability_data()$sustainability_tracked)
state_log_exists <- file.exists(paste0(log_dir, "/aifeducation_state.log"))
expect_true(state_log_exists)
if (state_log_exists) {
log_state <- read.csv(paste0(log_dir, "/aifeducation_state.log"))
expect_equal(nrow(log_state), 3)
expect_equal(ncol(log_state), 3)
expect_equal(colnames(log_state), c("value", "total", "message"))
unlink(paste0(log_dir, "/aifeducation_state.log"))
}
loss_log_exists <- file.exists(paste0(log_dir, "/aifeducation_loss.log"))
expect_true(loss_log_exists)
if (loss_log_exists == TRUE) {
log_loss <- read.csv(paste0(log_dir, "/aifeducation_loss.log"), header = FALSE)
expect_gte(ncol(log_loss), 2)
expect_gte(nrow(log_loss), 2)
unlink(paste0(log_dir, "/aifeducation_loss.log"))
}
})
gc()
}
}
# Clean Directory--------------------------------------------------------------
if (dir.exists(root_path_results)) {
unlink(
x = root_path_results,
recursive = TRUE
)
}
}
}
object_class_name
class_range
n_classes=2
# Create a List of all relevant combinations of arguments and reduce the number
# to the desired sample size.
# These are available for all tests.
test_combinations <- generate_args_for_tests(
object_name = object_class_name,
method = "configure",
max_samples = check_adjust_n_samples_on_CI(
n_samples_requested = max_samples,
n_CI = max_samples_CI
),
var_objects = list(
feature_extractor = feature_extractor
),
necessary_objects = list(
text_embeddings = test_embeddings,
target_levels = target_levels[[n_classes]]
),
var_override = list(
name = NULL,
label = "Classifier for Estimating a Postive or Negative Rating of Movie Reviews",
sustain_interval = 30,
act_fct = "elu",
rec_dropout = 0.1,
dense_dropout = 0.1,
encoder_dropout = 0.1,
intermediate_features=10,
tf_dense_dim=26,
tf_parametrizations="None",
dense_parametrizations="None",
rec_parametrizations="None",
conv_parametrizations="None",
tf_act_fct="elu",
dense_act_fct="gelu",
conv_act_fct="relu",
rec_act_fct="tanh",
feat_act_fct="prelu",
tf_num_heads=2,
tf_bias=TRUE,
dense_bias=TRUE,
rec_bias=TRUE,
conv_bias=TRUE,
dense_dropout=0.1,
rec_dropout=0.1,
tf_dropout_rate_1=0.1,
tf_dropout_rate_1=0.1,
conv_dropout=0.1,
feat_dropout=0.1,
conv_ks_min=2,
conv_ks_max=3,
trace = FALSE,
epochs = 50,
batch_size = 20,
ml_trace = 0,
n_cores = 2,
data_folds = 2,
pl_max_steps = 2,
pl_max = 1,
pl_anchor = 1,
pl_min = 0,
sustain_track = TRUE,
sustain_iso_code = "DEU",
data_val_size = 0.25,
lr_rate = 1e-3,
optimizer = "adamw",
dense_size = 5,
rec_size = 5,
self_attention_heads = 2,
intermediate_size = 6,
lr_warm_up_ratio = 0.01
)
)
i=1
classifier <- NULL
gc()
# Create test object with a given combination of args
classifier <- create_object(object_class_name)
do.call(
what = classifier$configure,
args = test_combinations$args[[i]]
)
predictions <- classifier$predict(
newdata = test_embeddings_reduced,
batch_size = 2,
ml_trace = 0
)
test_embeddings_reduced
test_embeddings_reduced$n_rows()
predictions <- classifier$predict(
newdata = test_embeddings_reduced,
batch_size = 2,
ml_trace = 0
)
reticulate::py_last_error()
predictions <- classifier$predict(
newdata = test_embeddings_reduced,
batch_size = 2,
ml_trace = 0
)
# Create a List of all relevant combinations of arguments and reduce the number
# to the desired sample size.
# These are available for all tests.
test_combinations <- generate_args_for_tests(
object_name = object_class_name,
method = "configure",
max_samples = check_adjust_n_samples_on_CI(
n_samples_requested = max_samples,
n_CI = max_samples_CI
),
var_objects = list(
feature_extractor = feature_extractor
),
necessary_objects = list(
text_embeddings = test_embeddings,
target_levels = target_levels[[n_classes]]
),
var_override = list(
name = NULL,
label = "Classifier for Estimating a Postive or Negative Rating of Movie Reviews",
sustain_interval = 30,
act_fct = "elu",
rec_dropout = 0.1,
dense_dropout = 0.1,
encoder_dropout = 0.1,
intermediate_features=10,
tf_dense_dim=26,
tf_parametrizations="None",
dense_parametrizations="None",
rec_parametrizations="None",
conv_parametrizations="None",
tf_act_fct="elu",
dense_act_fct="gelu",
conv_act_fct="relu",
rec_act_fct="tanh",
feat_act_fct="prelu",
tf_num_heads=2,
tf_bias=TRUE,
dense_bias=TRUE,
rec_bias=TRUE,
conv_bias=TRUE,
dense_dropout=0.1,
rec_dropout=0.1,
tf_dropout_rate_1=0.1,
tf_dropout_rate_1=0.1,
conv_dropout=0.1,
feat_dropout=0.1,
conv_ks_min=2,
conv_ks_max=3,
trace = FALSE,
epochs = 50,
batch_size = 20,
ml_trace = 0,
n_cores = 2,
data_folds = 2,
pl_max_steps = 2,
pl_max = 1,
pl_anchor = 1,
pl_min = 0,
sustain_track = TRUE,
sustain_iso_code = "DEU",
data_val_size = 0.25,
lr_rate = 1e-3,
optimizer = "adamw",
dense_size = 5,
rec_size = 5,
self_attention_heads = 2,
intermediate_size = 6,
lr_warm_up_ratio = 0.01
)
)
# Create test object with a given combination of args
classifier <- create_object(object_class_name)
# Create test object with a given combination of args
classifier <- create_object(object_class_name)
# Create test object with a given combination of args
classifier <- create_object(object_class_name)
do.call(
what = classifier$configure,
args = test_combinations$args[[i]]
)
predictions <- classifier$predict(
newdata = test_embeddings_reduced,
batch_size = 2,
ml_trace = 0
)
root_path_data=testthat::test_path("test_data_tmp/Embeddings")
imdb_embeddings<-load_from_disk(paste0(root_path_data,"/imdb_embeddings"))
review_embeddings=imdb_embeddings$convert_to_LargeDataSetForTextEmbeddings()
#model_path="Trial/google-bert_bert-large-cased-whole-word-masking"
model_path="Trial/bert-base-uncased"
example_data <- imdb_movie_reviews
example_data$label <- as.character(example_data$label)
example_data$label[c(76:100)] <- NA
example_data$label[c(201:250)] <- NA
example_targets <- as.factor(example_data$label)
table(example_data$label)
review_labels<-factor(example_data$label,levels=c("neg","pos"))
names(review_labels)<-rownames(imdb_embeddings$embeddings)
vignette_classifier <- TEClassifierSequentialPrototype$new()
vignette_classifier$configure(
name = "movie_review_classifier",
label = "Classifier for Estimating a Postive or Negative Rating of Movie Reviews",
text_embeddings = review_embeddings,
embedding_dim = 2,
feature_extractor = NULL,
target_levels = c("neg", "pos"),
intermediate_features=50,
cls_pooling_type="min_max",
residual_type="residual_gate",
normalization_type="layer_norm",
metric_type="euclidean",
feat_act_fct="elu",
feat_size=50,
feat_bias=TRUE,
feat_dropout=0.0,
feat_parametrizations="None",
conv_act_fct="elu",
conv_n_layers=1,
conv_ks_min=2,
conv_ks_max=4,
conv_bias=FALSE,
conv_parametrizations="None",
dense_act_fct="elu",
dense_n_layers=1,
dense_dropout=0.0,
dense_bias=FALSE,
dense_parametrizations="None",
rec_act_fct="tanh",
rec_n_layers=1,
rec_type="gru",
rec_bidirectional=FALSE,
rec_dropout=0.0,
rec_bias=FALSE,
rec_parametrizations="None",
tf_act_fct="elu",
tf_dense_dim=50,
tf_n_layers=1,
tf_dropout_rate_1=0.0,
tf_dropout_rate_2=0.0,
tf_attention_type="multi_head",
tf_positional_embedding="absolute",
tf_num_heads=1,
tf_bias=FALSE,
tf_parametrizations="None",
optimizer = "adamw"
)
vignette_classifier$configure(
name = "movie_review_classifier",
label = "Classifier for Estimating a Postive or Negative Rating of Movie Reviews",
text_embeddings = review_embeddings,
embedding_dim = 2,
feature_extractor = NULL,
target_levels = c("neg", "pos"),
intermediate_features=50,
cls_pooling_type="min_max",
residual_type="residual_gate",
normalization_type="layer_norm",
metric_type="euclidean",
feat_act_fct="elu",
feat_size=50,
feat_bias=TRUE,
feat_dropout=0.0,
feat_parametrizations="None",
conv_act_fct="elu",
conv_n_layers=1,
conv_ks_min=2,
conv_ks_max=4,
conv_bias=FALSE,
conv_parametrizations="None",
dense_act_fct="elu",
dense_n_layers=1,
dense_dropout=0.0,
dense_bias=FALSE,
dense_parametrizations="None",
rec_act_fct="tanh",
rec_n_layers=1,
rec_type="gru",
rec_bidirectional=FALSE,
rec_dropout=0.0,
rec_bias=FALSE,
rec_parametrizations="None",
tf_act_fct="elu",
tf_dense_dim=50,
tf_n_layers=1,
tf_dropout_rate_1=0.0,
tf_dropout_rate_2=0.0,
tf_attention_type="multi_head",
tf_embedding_type="absolute",
tf_num_heads=1,
tf_bias=FALSE,
tf_parametrizations="None",
optimizer = "adamw"
)
install.packages("aifeducation")
aifeducation::start_aifeducation_studio()
aifeducation::start_aifeducation_studio()
reticulate::use_virtualenv("aifeducation")
devtools::load_all()
devtools::test_active_file()
devtools::test_active_file()
devtools::test_active_file()
devtools::test_active_file()
devtools::test_active_file()
devtools::test_active_file()
?TEClassifierParallelPrototype
?TEClassifierParallel
get_TEClassifiers_class_names(super_class = "TEClassifiersBasedOnProtoNet")
abc=TEClassifierParallel$new
class(ab)
class(abc)
abc=TEClassifierParallel$new()
class(abc)
TEClassifiersBasedOnProtoNet %in% class(abc)
"TEClassifiersBasedOnProtoNet" %in% class(abc)
devtools::load_all()
# config------------------------------------------------------------------------
object_class_names <- get_TEClassifiers_class_names(super_class = "TEClassifiersBasedOnProtoNet")
devtools::load_all()
# config------------------------------------------------------------------------
object_class_names <- get_TEClassifiers_class_names(super_class = "TEClassifiersBasedOnProtoNet")
devtools::load_all()
# config------------------------------------------------------------------------
object_class_names <- get_TEClassifiers_class_names(super_class = "TEClassifiersBasedOnProtoNet")
super_class="TEClassifiersBasedOnProtoNet"
object=abc
TEClassifiers_class_names
class_names <- NULL
for (class in TEClassifiers_class_names) {
object <- create_object(class)
print(class(object))
print(super_class)
if (super_class %in% class(object)) {
class_names <- append(
x = class_names,
values = class
)
print(super_class %in% class(object))
}
}
class_names
class="TEClassifierParallel"
object <- create_object(class)
print(class(object))
class
print(class(object))
devtools::test_active_file()
reticulate::py_last_error()
devtools::test_active_file()
