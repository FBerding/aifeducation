#'@title Text embedding classifier with a neural net
#'
#'@description Abstract class for neural nets with 'keras'/'tensorflow' and
#''pytorch'.
#'
#'@return Objects of this class are used for assigning texts to classes/categories. For
#'the creation and training of a classifier an object of class \link{EmbeddedText} and a \code{factor}
#'are necessary. The object of class \link{EmbeddedText} contains the numerical text
#'representations (text embeddings) of the raw texts generated by an object of class
#'\link{TextEmbeddingModel}. The \code{factor} contains the classes/categories for every
#'text. Missing values (unlabeled cases) are supported. For predictions an object of class
#'\link{EmbeddedText} has to be used which was created with the same text embedding model as
#'for training.
#'@family Classification
#'@export
AIFEBaseModel<-R6::R6Class(
  classname = "AIFEBaseModel",
  public = list(
    #'@field model ('tensorflow_model' or 'pytorch_model')\cr
    #'Field for storing the tensorflow or pytorch model after loading.
    model=NULL,

    #'@field model_config ('list()')\cr
    #'List for storing information about the configuration of the model.
    model_config=list(),

    #'@field last_training ('list()')\cr
    #'List for storing the history, the configuration, and the results of the last training. This
    #'information will be overwritten if a new training is started.
    #'\itemize{
    #'\item{\code{last_training$start_time: }Time point when training started.}
    #'\item{\code{last_training$learning_time: }Duration of the training process.}
    #'\item{\code{last_training$finish_time: }Time when the last training finished.}
    #'\item{\code{last_training$history: }History of the last training.}
    #'\item{\code{last_training$data: }Object of class \code{table} storing the initial frequencies of the passed data.}
    #'\item{\code{last_training$config: }List storing the configuration used for the last training.}
    #'}
    last_training=list(
      learning_time=NULL,
      start_time=NA,
      history=list(),
      data=NULL,
      finish_time=NULL,
      config=list()
    ),
    #Check Embedding Model compatibility of the text embedding
    #'@description Method for checking if the provided text embeddings are
    #'created with the same \link{TextEmbeddingModel} as the classifier.
    #'@param text_embeddings Object of class \link{EmbeddedText}.
    #'@return \code{TRUE} if the underlying \link{TextEmbeddingModel} are the same.
    #'\code{FALSE} if the models differ.
    check_embedding_model=function(text_embeddings){
      if(("EmbeddedText" %in% class(text_embeddings))==FALSE){
        stop("text_embeddings is not of class EmbeddedText.")
      }

      embedding_model_config<-text_embeddings$get_model_info()
      to_check<-c("model_name")
      for(check in to_check){
        if(!is.null_or_na(embedding_model_config[[check]]) &
           !is.null_or_na(private$text_embedding_model$model[[check]])){
          if(embedding_model_config[[check]]!=private$text_embedding_model$model[[check]]){
            return(FALSE)
          }
        } else if (!is.null_or_na(embedding_model_config[[check]]) &
                   is.null_or_na(private$text_embedding_model$model[[check]])){
          return(FALSE)
        } else if (is.null_or_na(embedding_model_config[[check]]) &
                   !is.null_or_na(private$text_embedding_model$model[[check]])){
          return(FALSE)
        }
      }
      return(TRUE)
    },

    #General Information set and get--------------------------------------------
    #'@description Method for requesting the model information
    #'@return \code{list} of all relevant model information
    get_model_info=function(){
      return(list(
        model_license=private$model_info$model_license,
        model_name=private$model_info$model_name,
        model_name_root=private$model_info$model_name_root,
        model_label=private$model_info$model_label,
        model_date=private$model_info$model_date
      )
      )
    },
    #'@description Method for requesting the text embedding model information
    #'@return \code{list} of all relevant model information on the text embedding model
    #'underlying the classifier
    get_text_embedding_model=function(){
      return(private$text_embedding_model)
    },
    #---------------------------------------------------------------------------
    #'@description Method for setting publication information of the classifier
    #'@param authors List of authors.
    #'@param citation Free text citation.
    #'@param url URL of a corresponding homepage.
    #'@return Function does not return a value. It is used for setting the private
    #'members for publication information.
    set_publication_info=function(authors ,
                                  citation,
                                  url=NULL){

      private$publication_info$developed_by$authors<-authors
      private$publication_info$developed_by$citation<-citation
      private$publication_info$developed_by$url<-url

    },
    #--------------------------------------------------------------------------
    #'@description Method for requesting the bibliographic information of the classifier.
    #'@return \code{list} with all saved bibliographic information.
    get_publication_info=function(){
      return(private$publication_info)
    },
    #--------------------------------------------------------------------------
    #'@description Method for setting the license of the classifier.
    #'@param license \code{string} containing the abbreviation of the license or
    #'the license text.
    #'@return Function does not return a value. It is used for setting the private member for
    #'the software license of the model.
    set_software_license=function(license="GPL-3"){
      private$model_info$model_license<-license
    },
    #'@description Method for getting the license of the classifier.
    #'@param license \code{string} containing the abbreviation of the license or
    #'the license text.
    #'@return \code{string} representing the license for the software.
    get_software_license=function(){
      return(private$model_info$model_license)
    },
    #--------------------------------------------------------------------------
    #'@description Method for setting the license of the classifier's documentation.
    #'@param license \code{string} containing the abbreviation of the license or
    #'the license text.
    #'@return Function does not return a value. It is used for setting the private member for
    #'the documentation license of the model.
    set_documentation_license=function(license="CC BY-SA"){
      private$model_description$license<-license
    },
    #'@description Method for getting the license of the classifier's documentation.
    #'@param license \code{string} containing the abbreviation of the license or
    #'the license text.
    #'@return Returns the license as a \code{string}.
    get_documentation_license=function(){
      return(private$model_description$license)
    },
    #--------------------------------------------------------------------------
    #'@description Method for setting a description of the classifier.
    #'@param eng \code{string} A text describing the training of the learner,
    #'its theoretical and empirical background, and the different output labels
    #'in English.
    #'@param native \code{string} A text describing the training of the learner,
    #'its theoretical and empirical background, and the different output labels
    #'in the native language of the classifier.
    #'@param abstract_eng \code{string} A text providing a summary of the description
    #'in English.
    #'@param abstract_native \code{string} A text providing a summary of the description
    #'in the native language of the classifier.
    #'@param keywords_eng \code{vector} of keyword in English.
    #'@param keywords_native \code{vector} of keyword in the native language of the classifier.
    #'@return Function does not return a value. It is used for setting the private members for the
    #'description of the model.
    set_model_description=function(eng=NULL,
                                   native=NULL,
                                   abstract_eng=NULL,
                                   abstract_native=NULL,
                                   keywords_eng=NULL,
                                   keywords_native=NULL){
      if(!is.null(eng)){
        private$model_description$eng=eng
      }
      if(!is.null(native)){
        private$model_description$native=native
      }

      if(!is.null(abstract_eng)){
        private$model_description$abstract_eng=abstract_eng
      }
      if(!is.null(abstract_native)){
        private$model_description$abstract_native=abstract_native
      }

      if(!is.null(keywords_eng)){
        private$model_description$keywords_eng=keywords_eng
      }
      if(!is.null(keywords_native)){
        private$model_description$keywords_native=keywords_native
      }

    },
    #'@description Method for requesting the model description.
    #'@return \code{list} with the description of the classifier in English
    #'and the native language.
    get_model_description=function(){
      return(private$model_description)
    },
    #-------------------------------------------------------------------------
    #'@description Method for saving a model.
    #'@param dir_path \code{string()} Path of the directory where the model should be
    #'saved.
    #'@param save_format Format for saving the model. For 'tensorflow'/'keras' models
    #'\code{"keras"} for 'Keras v3 format',
    #'\code{"tf"} for SavedModel
    #'or \code{"h5"} for HDF5.
    #'For 'pytorch' models \code{"safetensors"} for 'safetensors' or
    #'\code{"pt"} for 'pytorch' via pickle.
    #'Use \code{"default"} for the standard format. This is keras for
    #''tensorflow'/'keras' models and safetensors for 'pytorch' models.
    #'@return Function does not return a value. It saves the model to disk.
    #'@importFrom utils write.csv
    save_model=function(dir_path,save_format="default"){
      if(private$ml_framework=="tensorflow"){
        if(save_format%in%c("safetensors","pt")){
          stop("'safetensors' and 'pt' are only supported for models based on
           pytorch.")
        }
      } else if(private$ml_framework=="pytorch"){
        if(save_format%in%c("keras","tf","h5")){
          stop("'keras','tf', and 'h5' are only supported for models based on
           tensorflow")
        }
      }

      if(save_format=="default"){
        if(private$ml_framework=="tensorflow"){
          save_format="keras"
        } else if(private$ml_framework=="pytorch"){
          save_format="safetensors"
        }
      }

      if(save_format=="safetensors" &
         reticulate::py_module_available("safetensors")==FALSE){
        warning("Python library 'safetensors' is not available. Using
                 standard save format for pytorch.")
        save_format="pt"
      }

      if(private$ml_framework=="tensorflow"){
        if(save_format=="keras"){
          extension=".keras"
        } else if(save_format=="tf"){
          extension=".tf"
        } else {
          extension=".h5"
        }
        file_path=paste0(dir_path,"/","model_data",extension)
        if(dir.exists(dir_path)==FALSE){
          dir.create(dir_path)
        }
        self$model$save(file_path)

        if(self$model_config$use_fe==TRUE){
          file_path_extractor=paste0(dir_path,"/","feature_extractor",extension)
          self$feature_extractor$model$save(file_path_extractor)
        }

      } else if(private$ml_framework=="pytorch"){
        if(dir.exists(dir_path)==FALSE){
          dir.create(dir_path)
        }
        self$model$to("cpu",dtype=torch$float)
        if(save_format=="safetensors"){
          file_path=paste0(dir_path,"/","model_data",".safetensors")
          safetensors$torch$save_model(model=self$model,filename=file_path)
        } else if (save_format=="pt"){
          file_path=paste0(dir_path,"/","model_data",".pt")
          torch$save(self$model$state_dict(),file_path)
        }

      }

      #Saving Sustainability Data
      sustain_matrix=t(as.matrix(unlist(private$sustainability)))
      write.csv(
        x=sustain_matrix,
        file=paste0(dir_path,"/","sustainability.csv"),
        row.names = FALSE
      )
    },
    #--------------------------------------------------------------------------
    #'@description Method for importing a model.
    #'@param dir_path \code{string()} Path of the directory where the model is
    #'saved.
    #'@param ml_framework \code{string} Determines the machine learning framework
    #'for using the model. Possible are \code{ml_framework="pytorch"} for 'pytorch',
    #'\code{ml_framework="tensorflow"} for 'tensorflow', and \code{ml_framework="auto"}.
    #'@return Function does not return a value. It is used to load the weights
    #'of a model.
    #'@importFrom utils compareVersion
    load_model=function(dir_path,
                        ml_framework="auto"){

      # Set the correct ml framework

      if((ml_framework %in%c("pytorch","tensorflow","auto","not_specified"))==FALSE){
        stop("ml_framework must be 'tensorflow', 'pytorch' or 'auto'.")
      }

      if(ml_framework=="not_specified"){
        stop("The global machine learning framework is not set. Please use
             aifeducation_config$set_global_ml_backend() directly after loading
             the library to set the global framework. ")
      }

      if(ml_framework!="auto"){
        private$ml_framework=ml_framework
      }

      #Load the model---------------------------------------------------------
      if(private$ml_framework=="tensorflow"){
        path=paste0(dir_path,"/","model_data",".keras")
        if(file.exists(paths = path)==TRUE){
          self$model<-keras$models$load_model(path)
        } else {
          path=paste0(dir_path,"/","model_data",".tf")
          if(dir.exists(paths = path)==TRUE){
            self$model<-keras$models$load_model(path)
          } else {
            path=paste0(dir_path,"/","model_data",".h5")
            if(file.exists(paths = path)==TRUE){
              self$model<-keras$models$load_model(paste0(dir_path,"/","model_data",".h5"))
            } else {
              stop("There is no compatible model file in the choosen directory.
                   Please check path. Please note that classifiers have to be loaded with
                   the same framework as during creation.")
            }
          }
        }
      } else if(private$ml_framework=="pytorch"){
        path_pt=paste0(dir_path,"/","model_data",".pt")
        path_safe_tensors=paste0(dir_path,"/","model_data",".safetensors")
        private$create_reset_model()
        if(file.exists(path_safe_tensors)){
          safetensors$torch$load_model(model=self$model,filename=path_safe_tensors)
        } else {
          if(file.exists(paths = path_pt)==TRUE){
            self$model$load_state_dict(torch$load(path_pt))
          } else {
            stop("There is no compatible model file in the choosen directory.
                     Please check path. Please note that classifiers have to be loaded with
                     the same framework as during creation.")
          }
        }
      }
    },
    #---------------------------------------------------------------------------
    #'@description Method for requesting a summary of the R and python packages'
    #'versions used for creating the classifier.
    #'@return Returns a \code{list} containing the versions of the relevant
    #'R and python packages.
    get_package_versions=function(){
      return(
        list(r_package_versions=private$r_package_versions,
             py_package_versions=private$py_package_versions)
      )
    },
    #---------------------------------------------------------------------------
    #'@description Method for requesting a summary of tracked energy consumption
    #'during training and an estimate of the resulting CO2 equivalents in kg.
    #'@return Returns a \code{list} containing the tracked energy consumption,
    #'CO2 equivalents in kg, information on the tracker used, and technical
    #'information on the training infrastructure.
    get_sustainability_data=function(){
      return(private$sustainability)
    },
    #---------------------------------------------------------------------------
    #'@description Method for requesting the machine learning framework used
    #'for the classifier.
    #'@return Returns a \code{string} describing the machine learning framework used
    #'for the classifier
    get_ml_framework=function(){
      return(private$ml_framework)
    }
  ),
  private = list(
    ml_framework=NA,

    #General Information-------------------------------------------------------
    model_info=list(
      model_license=NA,
      model_name=NA,
      name_root=NA,
      model_label=NA,
      model_date=NA
    ),

    text_embedding_model=list(
      model=list(),
      times=NA,
      features=NA
    ),

    publication_info=list(
      developed_by=list(
        authors =NULL,
        citation=NULL,
        url=NULL
      )
    ),

    model_description=list(
      eng=NULL,
      native=NULL,
      abstract_eng=NULL,
      abstract_native=NULL,
      keywords_eng=NULL,
      keywords_native=NULL,
      license=NA
    ),

    r_package_versions=list(
      aifeducation=NA,
      smotefamily=NA,
      reticulate=NA
    ),

    py_package_versions=list(
      tensorflow=NA,
      torch=NA,
      keras=NA,
      numpy=NA
    ),

    sustainability=list(
      sustainability_tracked=FALSE,
      date=NA,
      sustainability_data=list(
        duration_sec=NA,
        co2eq_kg=NA,
        cpu_energy_kwh=NA,
        gpu_energy_kwh=NA,
        ram_energy_kwh=NA,
        total_energy_kwh=NA
      ),
      technical=list(
        tracker=NA,
        py_package_version=NA,

        cpu_count=NA,
        cpu_model=NA,

        gpu_count=NA,
        gpu_model=NA,

        ram_total_size=NA
      ),
      region=list(
        country_name=NA,
        country_iso_code=NA,
        region=NA
      )
    ),

    gui=list(
      shiny_app_active=NA,
      pgr_value=0,
      pgr_max_value=0
    ),

    #--------------------------------------------------------------------------
    #Method for summarizing sustainability data for this classifier
    #List for results must correspond to the private fields of the classifier
    summarize_tracked_sustainability=function(sustainability_tracker){
      results<-list(
        sustainability_tracked=TRUE,
        sustainability_data=list(
          co2eq_kg=sustainability_tracker$final_emissions_data$emissions,
          cpu_energy_kwh=sustainability_tracker$final_emissions_data$cpu_energy,
          gpu_energy_kwh=sustainability_tracker$final_emissions_data$gpu_energy,
          ram_energy_kwh=sustainability_tracker$final_emissions_data$ram_energy,
          total_energy_kwh=sustainability_tracker$final_emissions_data$energy_consumed
        ),
        technical=list(
          tracker="codecarbon",
          py_package_version=codecarbon$"__version__",

          cpu_count=sustainability_tracker$final_emissions_data$cpu_count,
          cpu_model=sustainability_tracker$final_emissions_data$cpu_model,

          gpu_count=sustainability_tracker$final_emissions_data$gpu_count,
          gpu_model=sustainability_tracker$final_emissions_data$gpu_model,

          ram_total_size=sustainability_tracker$final_emissions_data$ram_total_size
        ),
        region=list(
          country_name=sustainability_tracker$final_emissions_data$country_name,
          country_iso_code=sustainability_tracker$final_emissions_data$country_iso_code,
          region=sustainability_tracker$final_emissions_data$region
        )
      )
      return(results)
    }
  )
)
